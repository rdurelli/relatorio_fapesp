\subsection{Disciplinas Regulares do Curso de Doutorado do ICMC/USP} % (fold)
\label{sub:disciplinas_regulares_do_curso_de_doutorado_do_icmc_usp}

De acordo com o tema central do projeto, foram escolhidas algumas disciplinas julgadas importantes para o bom aproveitamento do trabalho proposto no cronograma inicial. O quadro de disciplina cursadas pelo bolsista é mostrado a seguir:
% subsection disciplinas_regulares_do_curso_de_doutorado_do_icmc_usp (end)

\begin{enumerate}
	\item Engenharia de Software Experimental
		\begin{itemize}
			\item Carga Horária - 90
			\item Créditos: 6 (seis)
			\item Conceito Obtido: A
		\end{itemize}
	\item Revisão Sistemática em Engenharia de Software
		\begin{itemize}
			\item Carga Horária - 90
			\item Créditos: 6 (seis)
			\item Conceito Obtido: A
		\end{itemize}
	\item Validação e Teste de Software
		\begin{itemize}
			\item Carga Horária - 180
			\item Créditos: 12 (doze)
			\item Conceito Obtido: A
		\end{itemize}
	\item Preparação Pedagógica
		\begin{itemize}
			\item Carga Horária - 60
			\item Créditos: 4 (quatro)
			\item Conceito Obtido: A 
		\end{itemize}
	\item Especificação formal de software
		\begin{itemize}
			\item Carga Horária - 180
			\item Créditos: 12 (doze)
			\item Conceito Obtido: A
		\end{itemize}
\end{enumerate}

De acordo com as regras do Programa de Pós-Graduação em Ciências de Computação e Matemática Computacional do ICMC os alunos devem obter uma quantidade mínima de créditos para realizar determinadas tarefas, tais como, realizar o exame de qualificação e entregar a dissertação/tese. Nesse contexto, vale ressaltar que o bolsista em questão com o comprimento das disciplinas listadas a cima obteu-se um total de 40 créditos, sendo apto para realizar o exame de qualificação que exigi o mínimo de 24 créditos.%, bem como 36 créditos são necessários para o depósito da tese. 

Maiores informações sobre o desempenho do bolsista em cada uma das disciplinas e os conceitos obtidos podem ser avaliados mais cuidadosamente no histórico escolar deste relatório (ver Apêndice A).

%Conforme mencionado, durante o período deste relatório, o bolsista realizou tanto atividades técnicas requeridas para a concretização do seu projeto de doutorado quanto atividades exigidas pelo Programa de Pós-Graduação. Neste contexto, nesta subseção são apresentas e detalhadas as atividades técnicas realizadas até o momento. A seguir, cada uma das atividades realizadas é descrita.

\subsection{Estudo sobre Reengenharia} % (fold)
\label{sub:reengenharia}


Software é um produto que evolui constantemente para satisfazer às necessidades de seus usuários. Para isso é necessário submetê-lo a constantes atividades de manutenção, que podem degradar o código-fonte, tornando-se cada vez mais difícil de mantê-lo uma vez que, na maioria das vezes, o software não é atulizado, bem como a sua a documentação, culminando em uma situação em que a única documentação confiável é o código-fonte. Sistemas com essas características são denominados sistemas legados. Usualmente, sistemas legados são candidatos à reengenharia.


Segundo~\citet{refactImpro} reengenharia no contexto da evolução do software é utilizada para melhorar a qualidade do software, ou seja, melhorar a extensibilidade, modularidade, reusabilidade, complexidade e manutenibilidade. Por exemplo, reengenharia é útil para converter sistemas legados ou códigos deteriorados em unidades mais modularizadas ou até mesmo migrar tais sistemas para diferentes linguagens de programação e paradigmas.


De acordo com~\citet{chikofskyTax}, a reengenharia de software  é necessário para converter o código legado ou deteriorado em um código mais modular e estruturado, ou até mesmo alterar o paradigma de programação. 
%O processo de reengenharia usualmente consiste em seis principais atividades~\cite{Mens04}. A primeira consiste na identificação de qual(is) parte(s) do software devem ser reestruturado(s). Com o intuito de auxiliar essa atividade várias técnicas de mineração automáticas e semi-automáticas são encontradas na literatura~\cite{Cojocar2, Marin2, Bruntink10}. 
%Após a identificação da(s) parte(s) que deve(m) ser reestruturada(s) a segunda atividade consiste na escolha do melhor conjunto de transformação que deve ser aplicado no software. A terceira atividade consiste em garantir que o conjunto de transformação irá preservar o comportamento do sistema, uma vez que por definição, reengenharia não deve-se alterar o comportamento do software. Posteriormente, a quarta atividade consiste na efetiva realização da reengenharia do sistema, ou seja, efetuar as transformações no código-fonte. A quinta atividade tem como objetivo avaliar o efeitos das transformações efetuadas. Para isso, cada transformação deve ser analisada com base em seu propósito e efeito. Por exemplo, algumas reestruturações podem remover código redundante, elevam o nível de abstração, melhoram a capacidade de reutilização, etc. Dessa forma, a avaliação das reestruturações usualmente são realizadas com a utilização de métricas. Por fim, manter a coerência entre o código-fonte e outros artefatos, tais como, documentos de projeto, documentos de requisitos, testes, etc.
Segundo~\citet{Sneed:2005} mais da metade dos projetos que aplicam reengenharia falham ao lidar com desafios específicos. De acordo com esse autor, tanto a carência de  padronização durante a atividade de reengenharia quanto a falta de apoio computacional efetivo são os principais problemas que acarretam esse grande número de falhas.  

A falta de um processo padronizado de reengenharia usualmente é um problema pois, usualmente tal processo é realizado de forma totalmente \textit{ad hoc}. Além disso, a carência de um apoio computacional efetivo para auxiliar a atividade de reengenharia também é um problema, uma vez que tal atividade não é trivial e requer que várias mudanças sejam realizadas tanto no código-fonte como em outros artefatos, e.g., documentos de requisitos, casos de uso e diagrama de classes. 

% subsection evolu_o_de_software_e_reengenharia (end)

\subsection{Estudo sobre Desenvolvimento Dirigido a Modelos} % (fold)
\label{sub:desenvolvimento_dirigido_a_modelos}

A proposta do Desenvolvimento Dirigido a Modelos (\textit{Model-Driven Development - MDD}) é reduzir a distância semântica entre o problema do domínio e a solução/implementação. Assim, o engenheiro de software não precisa interagir inteiramente com o código-fonte, podendo-se concentrar em modelos que possuem maiores níveis de abstração. Um mecanismo é responsável por gerar automaticamente o código-fonte por meio dos modelos. No MDD, modelos não apenas guiam as tarefas de desenvolvimento e manutenção, mas são partes integrante do software assim como o código-fonte, servindo como entrada para ferramentas de geração de código reduzindo os esforços dos desenvolvedores~\cite{Bittar, Kleppe:2003}


No desenvolvimento tradicional, ou seja, sem seguir o MDD, artefatos de alto nível (ex., modelos, diagramas) usualmente são produzidos antes da codificação e costumam ser úteis apenas nas etapas iniciais do ciclo de desenvolvimento. Conforme o desenvolvimento evolui, mudanças são aplicadas somente no código-fonte e não nos modelos/diagramas. Assim, tais artefatos acabam se tornando incoerentes, ou seja, não refletem o que o código-fonte apresenta, o que faz com que o tempo e os esforços gastos na construção desses artefatos não sejam diretamente aproveitados na produção do software~\cite{Bittar}. Contrapartida, o MDD tem o foco nos modelos e busca simplificar o processo de desenvolvimento de software. Modelos são mais intuitivos para representação do conhecimento e menos dependentes do código-fonte, de forma que podem ser reutilizados facilmente em diferentes projetos. Diferentemente, o código-fonte possui uma linguagem que é densa e codificada, tornando-se difícil identificar, extrair e reutilizar o conhecimento apenas pela leitura do mesmo~\citep{Kleppe:2003}.



% subsection desenvolvimento_dirigido_a_modelos (end)

\subsection{Estudo sobre Modernização Dirigida à Arquitetura } % (fold)
\label{sub:estudo_sobre_moderniza_o_dirigida_arquitetura_}

A OMG (\textit{Object Management Group}) propôs a abordagem Modernização Dirigida à Arquitetura (\textit{Architecture-Driven Modernization} - ADM), a qual tem como intuito automatizar e formalizar/padronizar o problema tradicional da reengenharia de software, i.e., ADM melhora a abordagem  de reengenharia de software tradicional com a utilização de MDD~\cite{PerezCastillo:2011jo}. Segundo~\citet{rezCastillo:2011gm} ADM é uma padronização definida pela OMG para auxiliar a atividade de reengenharia de sistemas legados, com o diferencial da utilização dos princípios da MDD (ver Seção~\ref{Cap2_Sec2_Desenvolvimento_Dirigido_a_Modelos}). ADM difere das abordagens tradicionais de reengenharia de software por dois principais motivos: (\textit{i}) ADM considera todos os artefatos de um sistema legado como modelos e (\textit{ii}) refatorações do sistema legado são realizadas nos modelos e depois gera-se um novo código-fonte refatorado tendo como base tais modelos. 

De acordo com~\citet{PerezCastillo:2011jo} ADM tem algumas vantagens quando comparada com abordagens de reengenharia convencionais: (\textit{i}) permite que pesquisadores definam técnicas de refatorações independente de linguagem e plataforma; (\textit{ii}) refatorações podem ser definidas como modelos, assim, podem ser reutilizadas, ou seja, utiliza o metamodelo KDM, o qual tem como um dos objetivos aumentar a interoperabilidade entre as ferramentas de reengenharia e (\textit{iii}) com a abordagem ADM é possível criar técnicas de refatorações genéricas e específicas. 

% subsection estudo_detalhado_sobre_moderniza_o_dirigida_arquitetura_ (end)

\begin{itemize}

\item estudar ferramentas para criar uma Linguagem Específica de Domínio: fez-se necessário identificar e estudar algumas ferramentas que auxiliam o desenvolvimento de Linguagem Específica de Domínio. Foram identificadas as seguintes ferramentas, XText\footnote{http://www.eclipse.org/Xtext/}, Eclipse EMF\footnote{http://www.eclipse.org/modeling/emf/} e Eclipse GMF\footnote{http://www.eclipse.org/modeling/gmp/}. Tais ferramentas serão estudadas para o desenvolvimento de um Linguagem Específica de Domínio, a qual será utilizada no terceiro passo da abordagem proposta;

\item Estudo detalhado da abordagem denominada Arquitetura Dirigida a Modelo - (ADM): conforme descrito no projeto submetido anteriormente pretende-se criar uma abordagem para auxiliar o engenheiro de software durante a atividade de reestruturação de sistemas legados. Dessa forma, vez se necessário estudar realizar a modernização de sistemas legados com a utilizanção de 

\end{itemize}
